#To edit and compare internal_properties, use WINDEV integrated tools.
#Internal properties refer to the properties of controls in windows, reports, etc.
info :
 name : SyntaxeInstructionX86
 major_version : 25
 minor_version : 0
 type : 4
 description : ""
 subtype : 0
class :
 identifier : 0x1b6d31370407bf91
 internal_properties : BQAAAAUAAAB2/vstTMCJbS/hlxjFxirSqKvCUuv8YxgpWyl7S3iA
 code_elements :
  internal_properties : BQAAAAUAAACNovAR/6wlbzaEqZKonmKDsGl7Rn8TkHgPwmc47oRyHw6EhVIibzyTXadfYBW+Q4H7MZWHaJK0noShW6PGX6LdwmapNHiz0d3HvkCuynozZjwggdQAKPdQL8c=
  type_code : 10
  p_codes :
   -
     internal_properties : BQAAAAUAAACq/LpgEObhENIHQCgw4BofIND1yEO9TYQ1tCqfP3E8WOTJPWLShV/vW8lXqJ3SoALJpIwdk5iFG+4EvwK9UMhS/4GFCRRRsN2Jsl6ezFsnvW8hmEgjQjKSiYpbXJd+b2VC1EyCqmvaQiNKO//GYBhUrMeUZ6BRbccpUjsMZ8T17cWkm1PDducVA7QsKMZXknqv8yI7Cw==
     code : |1+
      // instruction X86 pour un syntaxe spécifique
      SyntaxeInstructionX86 est une Classe
      	mnemonique est chaine // nom de l'instruction en minuscules. ex "add" ou "ret"
      	opcode	   est buffer // code binaire principal a générer pour cette instruction. 1 a 4 octets
      	encodage   est chaine // options d'encodage des paramètres. ex ENCODAGE_ADDREGTOOPCODE
      	tabTypeParam   est un tableau de TypeOpérande // type des paramètres des l'instruction
      	syntaxeEnClair est chaine
      	
      FIN
     type : 131072
  procedures :
   -
     name : Constructeur
     procedure_id : 1976289923846160273
     type_code : 27
     code : |1-
      PROCEDURE Constructeur()
     type : 589824
   -
     name : Destructeur
     procedure_id : 1976289923846225809
     type_code : 28
     code : |1+
      PROCEDURE Destructeur()
     type : 655360
   -
     name : bEstcompatibleAvecTabValeur
     internal_properties : BQAAAAUAAAACJNLoRv7MjmQ76GJm4JofPuCfdGVDFcKfEOpRXSH06AYdO4rsJ8NhPa3L+tOqeBp3FBqFATb1FcgIZ9gHzJyOvVG/baILbF+bnmVt9SjIumqSMdPAT8UhAHFuY4BreALBTXU5s8zJRS7lYg7fPYXlDyBd6s2OoIKcZWbbOBEmkhjpeHJ8v65McrMbO8OAKPA3e7qTow==
     procedure_id : 1976289923846291345
     type_code : 12
     code : |1+
      PROCÉDURE bEstcompatibleAvecTabValeur( tabValeurParam est un tableau de ValeurOpérande,  contexte est ContexteCompilation dynamique ) : booléen
      
      // si même nombre de paramètre
      si tabTypeParam.Occurrence() <> tabValeurParam.Occurrence() ALORS
      	renvoyer  faux
      FIN
      
      // cas particulier REX en 64 bits : de 0x40 a 0x48 
      // instructiont DEC 32 bits non utilisables en mode 64, il faut utiliser la version rp/mod en 0xFE
      si contexte.compilateur.b64Bits() 
      	si :opcode=Caract(0x40)  ALORS renvoyer faux
      	si :opcode=Caract(0x48)  ALORS renvoyer faux
      	
      FIN
      
      // vérification pour chaque paramètre que son type est compatible avec la syntaxe
      pour i = 1 _a_  tabTypeParam.Occurrence()
      	opTypeI est TypeOpérande <- tabTypeParam[i]
      	si pas opTypeI.bEstcompatibleAvecValeur(tabValeurParam[i], contexte) ALORS
      		// pas OK 
      		renvoyer faux
      	FIN
      FIN
      
      RENVOYER Vrai
     type : 458752
   -
     name : InitFromDescription
     internal_properties : BQAAAAUAAABGaWuZPCRFBjnSFT6c6ONoC+6rHskAjPab3oOMDSe8ojiSOr61UG9pzndoB3y/jV8V0r4OnAKZ0GT9XLBMGtAEK26fkZ4o/hpFMjJvp+j1U74sVAskWhlSXdzMDWIy1rNfeuB/p0kNotf80r7tmj2oJ6HAaHkj7vHLavwDTFzkBNEZej8bdafmhL8M9kA8apWCDzi0wPGUOKi5oUb/s6l1yLjLvA==
     procedure_id : 1976289923846356881
     type_code : 12
     code : |1+
      // Initialisation d'une instruction a partir d'une de description au format CVS
      // = séparé par des ";"
      // ex : ADD;r/m8;r8;;;;0;;r
      Procédure InitFromDescription( local sDesc est chaine)
      
      // supprimer espace et TAB
      sDesc = Remplace(sDesc,tab  ,"")
      sDesc = Remplace(sDesc," "  ,"")
      si sDesc="" ALORS
      	retour
      FIN
      
      :syntaxeEnClair = remplace(sDesc,";", " ")
      // extraction des paramètres
      
      // nom de l'instruction en minuscules......
      // ex: "add" ou "call"
      mnemonique		   			= minuscule( ExtraitChaîne(sDesc,1,";") )
      
      // code binaire encodant cette instruction, de 1 a 4 octets
      sOpoCodeHex est une chaîne
      pour i = 6 a 9
      	sOctetI est chaine = ExtraitChaîne(sDesc,i,";")
      	si sOctetI<>"" ALORS
      		si taille(sOctetI)=1 alors sOctetI = "0" + sOctetI // force sur 2 octets
      		sOpoCodeHex += sOctetI
      	FIN
      FIN
      
      // type d'encodage des paramètres
      //"" si rien de spécial
      :encodage 					= ExtraitChaîne(sDesc,10,";") 
      dbgAssertion(:encodage <> EOT)
      
      // si l'opcode fini par "+r"
      si Droite(sOpoCodeHex,2)="+r" alors
      	// encodage de l'opérande (registre) dans les bits de poids faible de l'opération. 
      	:encodage 					= ENCODAGE_ADDREGTOOPCODE
      	// enlève le "+r"
      	sOpoCodeHex = milieu(sOpoCodeHex,1,taille(sOpoCodeHex)-2)
      FIN
      
      :opcode	  		    	   = HexaVersBuffer(SansEspace(sOpoCodeHex) )
      
      // décodage des paramètres de l'instruction...... 4 au max
      pour i = 1 a 4
      	// récup de la chaine donnant le type du paramètre
      	paramI est chaine = Minuscule( ExtraitChaîne(sDesc,1+i,";"))
      	// "" indique qu'il n'y en a plus
      	si paramI="" ALORS
      		sortir
      	fin
      	// ajout du type de paramètre
      	opTypeI est TypeOpérande 
      	opTypeI.nomType = paramI
      	tabTypeParam.Ajoute(opTypeI)
      FIN
      
     type : 458752
   -
     name : GetSyntaxe
     procedure_id : 1976289923846422417
     type_code : 12
     code : |1-
      procédure GetSyntaxe()
      
      res est chaine = mnemonique 
      POUR TOUT paramI DE tabTypeParam
      	res +="," + paramI.nomType
      FIN
      renvoyer res
     type : 458752
   -
     name : _bBitRex
     procedure_id : 2020876198340613409
     type_code : 12
     code : |1+
      // indique si un bit du préfixe REX doit être mis a 1 pour un paramètreS.
      // ex: R9
      procédure _bBitRex( operande est ValeurOpérande  ) : booléen
      
      // cas des registres R8,R9, ... R15
      si operande.bEstModeRegistre()    _ou_ ...
         operande.bEstModeIndirection() ALORS
      	nReg est un entier = nIndiceRegistre( operande.registre)
      	renvoyer nReg>=8
      FIN
      // cas des valeurs immédiates de 64 bits
      si operande.bEstModeValeurImmediate() 
      	si operande.nGetTailleEnBit()=64 ALORS
      		RENVOYER 1
      	sinon
      		renvoyer 0
      	fin
      FIN
      
      //@autres : TODO
      dbgAssertion(faux, "cas non géré" + operande.modeAdres.nom )
      renvoyer 0
     type : 458752
   -
     name : _WRXB_PourREXouVeX
     procedure_id : 2171126158774637368
     type_code : 12
     code : |1-
      // renvoie les 4 booléen W,R, X,B pour l'encodage REW/VEX
      procédure _WRXB_PourREXouVeX(tabValeurParam est un tableau de ValeurOperande) : (booléen, booléen, booléen, booléen)
      
      w	est un booléen		= 1	// 0 = Operand size determined by CS.D / 1 = 64 Bit Operand Size
      R	est un booléen			// Extension of the ModR/M reg field
      X	est un booléen			// Extension of the SIB index field
      B	est un booléen			// Extension of the ModR/M R/m field, SIB base field, or Opcode reg field
      
      
      SI :encodage = ENCODAGE_RM  // spécial R/M (2 reg dans 1 octets)
      	R	= _bBitRex( tabValeurParam[1] )
      	B	= _bBitRex( tabValeurParam[2] )
      	SI  tabTypeParam[1].bModeEncodageRM() ALORS
      		// si la syntaxe commence par r/M ex: MOV	r/m16/32	r16/32
      		// l'ordre src/dest est inversé
      		R<=>B
      	FIN	
      	SI  tabValeurParam.Occurrence()=2 ALORS
      		// cas mov  rax,qword ptr [r8+r12+1]
      		SI tabValeurParam[2].registre2<>""  _ET_ nIndiceRegistre(  tabValeurParam[2].registre2)>7 ALORS
      			X=1
      		FIN	
      	FIN
      	
      SINON
      	SI  tabValeurParam.Occurrence()=1 ALORS
      		B = _bBitRex( tabValeurParam[1] ) // cas "INC R10"
      	FIN
      	SI  tabValeurParam.Occurrence()=2 ALORS
      		R	= _bBitRex( tabValeurParam[1] ) 
      		B	= _bBitRex( tabValeurParam[2] )	
      		
      	FIN
      	SI  tabValeurParam.Occurrence()=3  ALORS
      		R = _bBitRex( tabValeurParam[3] )	
      		
      	FIN
      	
      FIN
      renvoyer (w,R,X,B)
     type : 458752
   -
     name : _EncodePrefix_REX
     internal_properties : BQAAAAUAAAApG0o1Pt5A+FVLcUpfk4GRsWXA+VeOCjHmHkITaWbGEiXj7T7gsVhwgoT2V3FF+WV+j1aNAXAjTwAcSXmls8WO0SRiGMLkHTwUS8AQJ0Ch2QfqJ2gKMVvZLJhCs4c+I6vE6XArviM+qeRgisYGfiZqBs6kdra9NWpqHkAt24QpINbmYiUwozFs0W8WO6fObir3K8zeE+xrk6lpcAURRMVzYAG5OfpT/+vL9uhjnjV6CiH2Gg==
     procedure_id : 2020855827309328332
     type_code : 12
     code : |1+
      // encoder le préfixe REX en 64 bits 
      // (pour accéder aux registre R8 par ex.)
      // voir par ex : https://xem.github.io/minix86/manual/intel-x86-and-64-manual-vol2/o_b5573232dd8f1481-69.html
      procédure _EncodePrefix_REX(tabValeurParam est un tableau de ValeurOpérande,  contexte est ContexteCompilation dynamique) : buffer
      
      SI tabValeurParam.Occurrence()<1 ALORS
      	renvoyer ""
      FIN
      si contexte.tailleOpérande<64 ALORS
      	renvoyer ""
      FIN
      // registre 32 bits : pas de préfixe REX. cas mov eax, 1
      si bEstRegistreDeType( tabValeurParam[1].registre, REGISTRE_32BITS) ALORS
      	renvoyer ""
      FIN
      
      // si le n° de registre est les bits de poids faible de l'instruction.
      SI :encodage = ENCODAGE_ADDREGTOOPCODE ALORS
      	// si instructionnnnnparamètrerererereree , ex PUSH
      	SI tabValeurParam.Occurrence()=1  alors
      		// pas besoin de REX pour les 8 premiers
      		nReg1 est un entier =  nIndiceRegistre(tabValeurParam[1].registre)
      		si nReg1 <= 7
      			renvoyer ""
      		fin
      		// REX : 0x41
      		RENVOYER Caract( 0x41 )
      	fin
      	//2 paramètres. ex MOV	RAX,1234
      	dbgassert(tabValeurParam.Occurrence()=2)
      	
      	
      FIN
      
      //  récup des booléen qui encodent les paramètres
      w est un booléen   = 1 // 0 = Operand size determined by CS.D / 1 = 64 Bit Operand Size
      R est un booléen	   // Extension of the ModR/M reg field
      X est un booléen	   // Extension of the SIB index field
      B est un booléen	   // Extension of the ModR/M R/m field, SIB base field, or Opcode reg field
      (W,R,X,B) =	_WRXB_PourREXouVeX(tabValeurParam)
      
      
      // Calcul final de REX
      nREX est un entier = 0x40 // 4 bits de poids fort
      si W ALORS	nREX = nREX | 0x08
      si R ALORS	nREX = nREX | 0x04
      si X ALORS	nREX = nREX | 0x02
      si B ALORS	nREX = nREX | 0x01
      
      
      renvoyer Caract( nREX )
     type : 458752
   -
     name : _EncodePrefix_VEX
     procedure_id : 2170759682100575087
     type_code : 12
     code : |1-
      // encoder le préfixe VEX des instructions:
      //voir https://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-software-developer-instruction-set-reference-manual-325383.pdf
      //     2.3.5 :
      //		The VEX prefix	is encoded in either the two-byte form (the first byte must be C5H) or in the three-byte form (the
      //		first byte must be C4H). The two-byte VEX	is used mainly for 128-bit, scalar, and the most common 256-bit AVX
      //		instructions; while the three-byte VEX provides a compact replacement of REX and 3-byte opcode instructions
      //		(including AVX and FMA instructions).
      // ex :   mulx        rax,rax,rax  => "C4 E2 FB F6 C0"     
      procédure _EncodePrefix_VEX(tabValeurParam est un tableau de ValeurOpérande,  contexte est ContexteCompilation dynamique) : buffer
      dbgAssertion(tabValeurParam.Occurrence() = 3) // seul ca géré
      
       // VEX sur 3 Bytes :
       // voir https://en.wikipedia.org/wiki/VEX_prefix
       
      //  récup des booléen qui encodent les paramètres
      //w	est un booléen		= 1	// 0 = Operand size determined by CS.D / 1 = 64 Bit Operand Size
      //R	est un booléen			// Extension of the ModR/M reg field
      //X	est un booléen			// Extension of the SIB index field
      //B	est un booléen			// Extension of the ModR/M R/m field, SIB base field, or Opcode reg field
      soit (W,R,X,B) =	_WRXB_PourREXouVeX(tabValeurParam)
       
       // Byte 0 : indique qu'on est un préfixe VEX sur 3:
      bufVEX est un buffer = caract(0xC4)
      // byte 1 : R̅	X̅	B̅	m4	m3	m2	m1	m0
      byteVex1 est un entier = 0
      SI pas R ALORS	byteVex1 = byteVex1 | 0x80
      SI pas X ALORS	byteVex1  =byteVex1 | 0x40
      SI pas B ALORS	byteVex1 = byteVex1 | 0x20
      // m replaces leading opcode prefix bytes. 
      // The values 1, 2 and 3 are equivalent to opcode prefixes 0F, 0F 38 and 0F 3A; all other values are reserved. m
      m est un entier 
      SI :opcode[1] <> Caract(0x0F) ALORS
      	dbgAssertion(Faux)
      	renvoyer "" // non géré
      FIN
      si       :opcode[2] = Caract(0x38) ALORS
      	m=2
      sinon si :opcode[2] = Caract(0x3A) ALORS
      	m=3
      SINON  
      	m=1
      FIN
      byteVex1 = byteVex1 | m
      bufVEX += caract(byteVex1)
      
      // byte 2 : W	v̅3	v̅2	v̅1	v̅0	L	p1	p0
      //v̅ is the inversion of an additional source register index.
      //L indicates the vector length; 0 for 128-bit SSE (XMM) registers, and 1 for 256-bit AVX (YMM) registers.
      //p encodes additional prefix bytes. The values 0, 1, 2, and 3 correspond to implied prefixes of none, 66, F3, and F2.
      //   These encode the operand type for SSE instructions: packed single, packed double, scalar single and scalar double, respectively.
      byteVex2 est un entier = 0
      v est un entier = tabValeurParam[3].registre + 1  
      v=  OUExclusifBinaire(v, 0xF) // vvvv: a register specifier (in 1’s complement form) or 1111 if unused.
      SI W ALORS	byteVex2 = byteVex2 | 0x80
       			byteVex2 = byteVex2 | (v * 8)
      bufVEX += Caract(byteVex2)
      
      
      dbgAssertion(taille(bufVEX) = 3) 
      renvoyer bufVEX
     type : 458752
   -
     name : Encode
     internal_properties : BQAAAAUAAADixHKI0GaoPsgjZNbqDPYTQjiP0FG7QcoLKD5F4X24LBI1Q67I16/hmW23Zg9WNLaTfNq5VYaxDfwoY8xjQOiqWZkX2e4zQPffTstHk4ZqfKxcC42uvTeXigvEXZ6ZUmyrP8dbmSITexCXkAAtqxf30WLHtDskqoCeRxTd3mdITEIbItwSBWiSTA2xrWEOahrXm1pzww==
     procedure_id : 1976289923846553489
     type_code : 12
     code : |1+
      // renvoyer l'instruction encodée (=le code x86 exécutable)
      // pour pour les paramètres <TabParam>
      Procédure encode(tabValeurParam est un tableau de ValeurOpérande,  contexte est ContexteCompilation dynamique) : buffer
      dbgAssertion(tabTypeParam.Occurrence() = tabValeurParam.Occurrence())
      
      code est un buffer
      nbParamTraite est un entier = 0
      
      // si on doit forcer le mode 16 bits
      si contexte.tailleOpérande=16 ALORS
      	code += Caract( 0x66 )
      FIN
      // si on doit forcer le mode 64 bits - REX ou VEX
      VEX_REX_Prefix est buffer
      SI contexte.compilateur.b64Bits() _et_ contexte.tailleOpérande=64 ALORS
      	// si 3 opérandes => VEX
      	si :encodage=ENCODAGE_VEX ALORS
      		// VEX :
      		VEX_REX_Prefix = _EncodePrefix_VEX(tabValeurParam, contexte)
      	sinon
      		// REX: 0100 WRXB 
      		VEX_REX_Prefix = _EncodePrefix_REX(tabValeurParam, contexte) // ex :  Caract( 0x40 )
      	fin
      	code 	  += VEX_REX_Prefix
      FIN
      
      
      // si encodage par ajoute du n° de registre a l'opcode (ex "POP")
      si :Encodage = ENCODAGE_ADDREGTOOPCODE ALORS
      	nReg est un entier = nIndiceRegistre(tabValeurParam[1].registre) 
      	// pour le cas des registres étendus 64 bits. ex R8
      	nReg = ETBinaire( nReg , 0x07) 
      	
      	code +=  caract( asc(:opcode) + nReg )
      	nbParamTraite++
      SInon si :encodage = ENCODAGE_VEX ALORS	
      	// l'OPCODE n'est que le denier octet. le reste est encodé dans VEX_REX_Prefix
      	dbgAssertion(taille(opcode)=3)
      	code +=  droite(:opcode,1)
      sinon
      	// OPCODE principal
      	code +=  :opcode 
      fin
      	
      // si encodage spécial R/M (2 opérandes registres dans 1 octets)
      SI :encodage = ENCODAGE_RM ALORS
      	rm est buffer
      	si  tabTypeParam[1].bModeEncodageRM() ALORS
      		// si la syntaxe commence par r/M ex: MOV	r/m16/32	r16/32
      		// l'ordre src/dest est inversé
      		rm = TypeOpérande::Encode_RM_REG( tabValeurParam[2], tabValeurParam[1] )
      	sinon
      		rm = TypeOpérande::Encode_RM_REG( tabValeurParam[1], tabValeurParam[2] )
      	fin
      	
      	code += rm
      	nbParamTraite += 2
      	RENVOYER code
      fin
      
      // valeur du champ REG dans la partie modRegRM.
      // ex : INC 0, DEC 1
      nForceReg_modRegRM est entier = Val(:encodage)
      contexte.offsetDansInstruction = taille(code)
      
      // paramètres 
      POUR i = nbParamTraite+1 _a_ :tabTypeParam.Occurrence()
      	soit typeParamI   = tabTypeParam[i]
      	valeurParamI est ValeurOpérande <- tabValeurParam[i]
      	contexte.offsetDansInstruction = Taille(code)
      	
      	// si la valeur est un label
      	si valeurParamI.bEstModeLabel() ALORS
      		valeurParamVide est ValeurOpérande 
      		codeAPatcher est un buffer = typeParamI.Encode( valeurParamVide, nForceReg_modRegRM, contexte )
      		// il faudra patcher ici
      		contexte.onUtilisationLabel( valeurParamI.label, taille(code), taille(codeAPatcher), typeParamI )
      		// encodage du paramètre avec 0 pour l'instant
      		code += codeAPatcher
      		//tabValeurParam
      		continuer
      	FIN
      	
      	// encodage du paramètre
      	code += typeParamI.Encode( valeurParamI, nForceReg_modRegRM, contexte )
      	
      	SI :encodage = ENCODAGE_VEX ALORS
      		sortir // on stop au 1er, le reste a été encodé dans le préfixe
      	FIN
      	
      FIN
      
      
      renvoyer code
      
     type : 458752
   -
     name : bEstMeilleureQue
     procedure_id : 1977062395187041756
     type_code : 12
     code : |1+
       // indique si on est une meilleure syntaxe (= on génère un code plus court)
       procédure bEstMeilleureQue( autreSyntaxe est SyntaxeInstructionX86 ) : booléen
      
      renvoyer _nEvalRapideTaillleCodeGénéré() <  autreSyntaxe._nEvalRapideTaillleCodeGénéré()
      
     type : 458752
   -
     name : _nEvalRapideTaillleCodeGénéré
     procedure_id : 1977062476791505041
     type_code : 12
     code : |1-
       // évaluation de de la taille générée pour choix de la meilleure syntaxe
       procédure _nEvalRapideTaillleCodeGénéré() : entier
      
      si :encodage = ENCODAGE_ADDREGTOOPCODE alors
      	renvoyer taille(:opcode)
      fin
      
      
      SI :encodage = ENCODAGE_RM ALORS
      	renvoyer Taille(:opcode) + 1
      fin
      
      nTailleParam est un entier = 0
      POUR i = 1 _a_ :tabTypeParam.Occurrence()
      	soit typeParamI   = tabTypeParam[i]
      	nTailleParam += typeParamI.nGetTailleEnBit()/8
      fin
      RENVOYER Taille(:opcode) + nTailleParam
      	
       
     type : 458752
  procedure_templates : []
  property_templates : []
 code_parameters :
  internal_properties : BQAAAAUAAAA6ih3UbgNXHwTtiPSFUEj+2fi/m7v4QV2rqidAupM=
  original_name : Classe1
resources :
 string_res :
  identifier : 0x1b65619800409942
  internal_properties : BQAAAAUAAAAnMYFQ1bL/vz9ehh7L22SNNSlIzGTOI8h5F/WtgDNP
custom_note :
 internal_properties : BQAAAAUAAABtB9HWVzrXO2+4NDRVK0vmzaNKrCKqH1DBX30lMmGZ
